[
  {
    "objectID": "intro/index.html",
    "href": "intro/index.html",
    "title": "Verona Interfaces - Einführung",
    "section": "",
    "text": "Es geht auf den Seiten dieser Dokumentation um große Vergleichsstudien oder Befragungen im Rahmen des nationalen Bildungsmonitorings. Hierfür ist der Begriff “Large Scale Assessments” etabliert. Die hohe Anzahl der Testpersonen soll ein datenbasiertes wissenschaftliches Monitoring des Bildungssystems ermöglichen, also Zusammenhänge sichtbar machen zwischen den Einflussfaktoren und dem Erreichen von Bildungszielen. Eine Vergleichsstudie ist in hohem Maße standardisiert und wird in einem engen Zeitfenster synchron durchgeführt.\nDer Fokus liegt also nicht auf der Einzelperson - der Schülerin oder des Schülers -, sondern auf Gruppen von Personen - Klassen, Schulen, Bezirke, Länder. Die Erkenntnisse aus den aufwändigen Testungen sollen aber nicht nur der obersten Steuerungsebene zufließen, sondern es ist an vielen Stellen eine Auswertung der Analyseergebnisse durch die Lehrkraft vorgesehen. Diese sogenannten Rückmeldungen ermöglichen durch den hohen Grad der Standardisierung eine Verortung der Leistungen der Klasse im Land und auch länderübergreifend.",
    "crumbs": [
      "Einführung"
    ]
  },
  {
    "objectID": "intro/index.html#lesen-sie-weiter",
    "href": "intro/index.html#lesen-sie-weiter",
    "title": "Verona Interfaces - Einführung",
    "section": "Lesen Sie weiter",
    "text": "Lesen Sie weiter\n\nComputerbasiertes Testen: Ein Einstieg in das Thema “Computerbasierte Vergleichsstudien” und institutionelle Szenarien\nArchitektur: Hier wird das Plug-in-System erläutert\nModul-Metadaten: Einem Modul müssen bestimmte Informationen beigegeben werden. Diese sind hier erläutert.\nKommunikationsmodell: Wenn ein Verona-Modul von einer Webanwendung geladen wird, ist die dann folgende Kommunikation standardisiert.\nDatenstrukturen: Was ist eine Unit und welche Daten spielen bei Verona-Modulen eine Rolle?",
    "crumbs": [
      "Einführung"
    ]
  },
  {
    "objectID": "intro/index.html#name-und-logo",
    "href": "intro/index.html#name-und-logo",
    "title": "Verona Interfaces - Einführung",
    "section": "Name und Logo",
    "text": "Name und Logo\nEine der großen Lernstandserhebungen in Deutschland ist unter dem Namen VERA bekannt (VERgleichsArbeiten), und aus der Kombination mit Online ist dann die Bezeichnung Verona entstanden. Das Logo1 stellt eine Leiter dar - italienisch “la scala”. Skalieren ist ein wichtiger methodischer Schritt bei der Auswertung der Antworten, und die Scaliger (Scaligeri, della Scala, deutsch oft auch Skaliger, historisch auch Herren von der Leiter) waren Herren der italienischen Stadt Verona von 1262 bis 1387. Die unterschiedlichen Einfärbungen zwischen den Sprossen stehen für verschiedene Endgeräte.",
    "crumbs": [
      "Einführung"
    ]
  },
  {
    "objectID": "intro/index.html#footnotes",
    "href": "intro/index.html#footnotes",
    "title": "Verona Interfaces - Einführung",
    "section": "Fußnoten",
    "text": "Fußnoten\n\n\ncredits to HoffmannP 2019↩︎",
    "crumbs": [
      "Einführung"
    ]
  },
  {
    "objectID": "intro/architecture.html",
    "href": "intro/architecture.html",
    "title": "Architektur",
    "section": "",
    "text": "Verona-Module als Plug-in\nUm für VERA die Länder bzw. die durchführenden Einrichtungen in die Lage zu versetzen, Aufgaben des IQB direkt einzusetzen, hat das IQB Komponenten für Webanwendungen entwickelt, die sich gut in vorhandene Webanwendungen einfügen lassen. Durch eine einfache standardisierte Schnittstelle wird diese Komponente in einen Bildschirmbereich geladen und kann anschließend die Aufgabe darstellen. Das Plug-in “Player” beispielsweise präsentiert alle Inhalte auf eine bei der Aufgabenentwicklung festgelegte Art und Weise (z. B. zeitverzögertes Audio, automatische Navigation, Textmarkierung, Aus- und Einblenden von Formular-Elementen je nach Stand der Beantwortung usw.).\n\n\n\n\n\nflowchart BT\n    subgraph Testsystem\n        TC[Testablaufsteuerung]--&gt;|Aufgabendefinition| P[Player]\n        style TC fill:white\n        style P fill:white\n        P--&gt;|Antworten| TC\n    end\n    style Testsystem fill:#d1d1e0,stroke:#d1d1e0\n    DB[(Datenbank)]&lt;--&gt; TC\n\n\n\n\n\n\nWährend einer Testung können Player-Module nach Bedarf ausgetauscht werden. Aus diesem Plug-in-Modell ergibt sich eine hohe Flexibilität für das Testsystem: Neue Funktionen der Interaktion führen nur zum Laden einer neuen Player-Version - das Testsystem bleibt unverändert. Weitere Vorteile:\n\nÄltere Player können alte Aufgaben lange abspielen - solange die Schnittstelle des Plug-ins unterstützt wird\nPlayer für besondere Anwendungsfälle (z. B. Lesegeschwindigkeitstest, Physik-Experimente) werden nur einmal programmiert und dann allen Interessierten zur Verfügung gestellt\n\nWir nennen die Webanwendung, die das Plug-in lädt, “Host”.\n\n\nTechnische Umsetzung\nEs handelt sich bei den Verona-Modulen um Code für das Frontend. Das Plug-in beansprucht einen rechteckigen Bereich des Bildschirmes und führt darin JavaScript aus. Um die Nebenwirkungen für den Host so gering wie möglich zu halten, ist das Modul technisch eine eigene Html-Seite, die in ein iframe-Element geladen wird. Die Kommunikation zwischen Host und Modul erfolgt asynchron über postMessage().\n\n\nKonventionen\nFür alle Module gelten folgende Grundsätze:\n\nDas Modul muss in einer einzigen Datei zusammengefasst sein. Der Build-Prozess muss also alle sonst separat vorliegenden Komponenten einer Html-Seite (Styles, Code, Schriften, Bilder usw.) zusammenbinden.\nAußer über postMessage() darf das Modul keinen weiteren Kontakt mit der Außenwelt pflegen. Jedweder Zugriff auf Ressourcen des Hosts (Frontend, Backend) oder auf andere Web-Ressourcen ist nicht gestattet.\nDem Modul werden Daten übergeben, die dann das Verhalten, die Erscheinung usw. beeinflussen. Ein Player z. B. bekommt die sog. Unit-Definition, ein Schemer das Unit-Kodierschema. Diese Daten dürfen selbst keinen Code enthalten.\nDas Modul muss Metadaten in einem JSON-LD-Format (z. B. Version, Maintainer usw., s. u.) enthalten.\n\n\n\nDatensicherheit\nDiese Konventionen dienen der Datensicherheit. Es muss eine verlässliche Basis für die Abschätzung von Risiken geben, die durch die Plug-in-Technik verursacht werden. Sollten diese Konventionen nicht eingehalten werden können, muss dazu eine ausführliche Dokumentation zur Verfügung stehen. Das Modul muss alles Machbare unternehmen, die aus der Abweichung resultierenden Risiken zu minimieren und zu dokumentieren. Beispiele:\n\nPlayer und Editor des Aspect-Paketes des IQB nutzen GeoGebra, also eine Programmierung Dritter. Dies wird während der Laufzeit je nach Bedarf nachgeladen. Das IQB steht in direktem Kontakt mit dem Entwicklungsteam, um Risiken abzuschätzen.\nDer Simple-Player und einige andere Module des IQB haben als Teil der Datenstruktur Html-Code, der dann zur Anzeige gebracht wird. Hier besteht potenziell ein Risiko, dass Code mit eingeschleust wird. Daher wird konsequent ein sog. Sanitizer verwendet, also eine Bibliothek, die verlässlich Code vor der Anzeige aus dem Html entfernt.",
    "crumbs": [
      "Einführung",
      "Architektur"
    ]
  },
  {
    "objectID": "intro/metadata.html",
    "href": "intro/metadata.html",
    "title": "Modul-Metadaten",
    "section": "",
    "text": "Ein Verona-Modul muss Metadaten enthalten. Der wichtigste Anwendungsfall hierfür ist die Auswahl und Speicherung von Modulen in Webanwendungen. Erst wenn z. B. die Bezeichnung und die Version eines Moduls auf standardisierte Art bekannt gemacht wird, können Anwender über die Verwendung sinnvoll entscheiden.\nEine Html-Seite kann auf diverse Arten Metadaten speichern. Im Verona-Kontext benutzen wir einen &lt;script&gt;-Block im Header, der ein JSON-Datenobjekt enthält. Diese Vorgehensweise wird als “Linked Data” bezeichnet, d. h. der Script-Typ wäre mit application/ld+json zu bezeichnen.",
    "crumbs": [
      "Einführung",
      "Modul-Metadaten"
    ]
  },
  {
    "objectID": "intro/metadata.html#id",
    "href": "intro/metadata.html#id",
    "title": "Modul-Metadaten",
    "section": "id",
    "text": "id\nDiese ID kann in internen Referenzen verwendet werden. Wenn beispielsweise eine Unitdefinition mit einem bestimmten Editor erzeugt wurde, kann die ID des Editor-Moduls die spätere Weiterarbeit sichern.\nAchtung: Um sicherzustellen, dass dann auch die passende Version des Moduls verwendet wird, sollte diese Version ebenfalls als Referenz abgespeichert werden, also z. B. iqb-editor-aspect@2.4.9. Dies kann auch der Dateiname des Moduls sein, obwohl in unixbasierten Systemen das @-Zeichen reserviert ist. Das IQB verwendet daher als Dateinamen die ID sowie die Version auf folgende Art: iqb-player-aspect-2.4.11.html.",
    "crumbs": [
      "Einführung",
      "Modul-Metadaten"
    ]
  },
  {
    "objectID": "intro/metadata.html#version",
    "href": "intro/metadata.html#version",
    "title": "Modul-Metadaten",
    "section": "version",
    "text": "version\nHier wird eine übliche SemVer-Notation erwartet, also auch mit Suffixen wie beta oder rc4.",
    "crumbs": [
      "Einführung",
      "Modul-Metadaten"
    ]
  },
  {
    "objectID": "intro/metadata.html#type",
    "href": "intro/metadata.html#type",
    "title": "Modul-Metadaten",
    "section": "type",
    "text": "type\nDie möglichen Werte dieser Aufzählung sind\n\n\n\nWert\nBeschreibung\n\n\n\n\nplayer\nEin Modul, das der Anzeige einer Unit dient. Es wird die Definition geladen, und eine Interaktion mit der Testperson startet\n\n\neditor\nEin Modul, das dem Ändern einer Unit-Defintion dient\n\n\nschemer\nEin Modul zur Änderung eines Kodierschemas für die Auswertung der Antworten\n\n\ncoder\nDieses Modul ist nur eine Idee. Ursprünglich war geplant, das automatische Kodieren ebenfalls als Verona-Modul zu implementieren. Aktuell wird dies jedoch über die Bereitstellung einer JavaScript-Klasse (npm) gelöst, die in Webanwendungen beim Build-Prozess eingebunden wird. Diese Programmierung kann also nicht zur Laufzeit dynamisch geladen werden. Dies stellt aktuell die bessere Lösung dar.",
    "crumbs": [
      "Einführung",
      "Modul-Metadaten"
    ]
  },
  {
    "objectID": "intro/metadata.html#name",
    "href": "intro/metadata.html#name",
    "title": "Modul-Metadaten",
    "section": "name",
    "text": "name\nDiese Bezeichnung erscheint als Label z. B. in Auswahllisten, da die ID zu knapp und wenig verständlich ist.",
    "crumbs": [
      "Einführung",
      "Modul-Metadaten"
    ]
  },
  {
    "objectID": "intro/metadata.html#description",
    "href": "intro/metadata.html#description",
    "title": "Modul-Metadaten",
    "section": "description",
    "text": "description\nHier soll eine knappe Beschreibung helfen, die Besonderheiten dieses Moduls zu erkennen und darüber zu entscheiden, ob das Modul für die eigenen Zwecke interessant sein könnte.",
    "crumbs": [
      "Einführung",
      "Modul-Metadaten"
    ]
  },
  {
    "objectID": "intro/metadata.html#specversion",
    "href": "intro/metadata.html#specversion",
    "title": "Modul-Metadaten",
    "section": "specVersion",
    "text": "specVersion\nDieser String erklärt, welche Version der Modul-Interfacedefinition unterstützt wird. Da Interfacedefinitionen einer Entwicklung unterliegen und Eigenschaften geändert und hinzugefügt werden, sollte sich eine Hostanwendung darauf einstellen, welchen Dialekt der Kommunikation das Modul versteht.\nAllerdings kann man diese Information auch ignorieren und als Host einfach alle Varianten unterstützen. Wenn eine bestimmte Information nicht gefunden wird in einem Datenobjekt eines Players, versucht der Host andere Bezeichnungen oder Datenformate entsprechend älterer Varianten der Spezifikation. Dieses defensive Verhalten erhöht die Robustheit der Programmierung, kann aber auch ernste Probleme verschleiern.",
    "crumbs": [
      "Einführung",
      "Modul-Metadaten"
    ]
  },
  {
    "objectID": "intro/tba.html",
    "href": "intro/tba.html",
    "title": "Computerbasiertes Testen",
    "section": "",
    "text": "Die folgenden Ausführungen beziehen sich stets auch auf Befragungen. Die Anforderungen an Befragungen sind ähnlich, aber meist einfacher umzusetzen. Es gibt beispielsweise keine Kodierung in “Richtig” oder “Falsch”.\nDass Befragungen hier auch technisch mit abgedeckt werden (können) liegt daran, dass große Studien zur Erfassung von Kompetenzen stets auch Befragungen mit einschließen. Auf diesem Weg ist es möglich, Einflussfaktoren über Personenmerkmale zu erheben.\n\n\n\nDas Durchführungsszenario sieht bei der Testperson ein Endgerät vor, das dem Begriff des “Computers” entspricht. Es sind also Desktop-Geräte, Laptops, Notebooks und teilweise auch Smartphones im Einsatz.\nDer Begriff “technologiebasiert” möchte betonen, dass es nicht unbedingt eines Computers bedarf, um digital Antworten zu erfassen. Prominentes Beispiel wäre ein Stift, der auf Spezialpapier Geschriebenes erkennt (scannen in Echtzeit) und in einen Speicher ablegt für spätere Auswertungen. Diese Überlegungen führten zum Begriff TBA - “Technologiebasiertes Assessment” oder “Technology Based Assessment”, wobei Technologie hier eher als Technik verstanden wird (Papierverfahren sind eigentlich auch Technologien).\nLetztlich sind diese Unterscheidungen hier nicht relevant und werden daher synonym verwendet. Man könnte auch eAssessment, digitales Testen usw. verwenden.",
    "crumbs": [
      "Einführung",
      "Computerbasiertes Testen"
    ]
  },
  {
    "objectID": "intro/tba.html#test-oder-befragung",
    "href": "intro/tba.html#test-oder-befragung",
    "title": "Computerbasiertes Testen",
    "section": "",
    "text": "Die folgenden Ausführungen beziehen sich stets auch auf Befragungen. Die Anforderungen an Befragungen sind ähnlich, aber meist einfacher umzusetzen. Es gibt beispielsweise keine Kodierung in “Richtig” oder “Falsch”.\nDass Befragungen hier auch technisch mit abgedeckt werden (können) liegt daran, dass große Studien zur Erfassung von Kompetenzen stets auch Befragungen mit einschließen. Auf diesem Weg ist es möglich, Einflussfaktoren über Personenmerkmale zu erheben.",
    "crumbs": [
      "Einführung",
      "Computerbasiertes Testen"
    ]
  },
  {
    "objectID": "intro/tba.html#computerbasiert-vs.-technologiebasiert",
    "href": "intro/tba.html#computerbasiert-vs.-technologiebasiert",
    "title": "Computerbasiertes Testen",
    "section": "",
    "text": "Das Durchführungsszenario sieht bei der Testperson ein Endgerät vor, das dem Begriff des “Computers” entspricht. Es sind also Desktop-Geräte, Laptops, Notebooks und teilweise auch Smartphones im Einsatz.\nDer Begriff “technologiebasiert” möchte betonen, dass es nicht unbedingt eines Computers bedarf, um digital Antworten zu erfassen. Prominentes Beispiel wäre ein Stift, der auf Spezialpapier Geschriebenes erkennt (scannen in Echtzeit) und in einen Speicher ablegt für spätere Auswertungen. Diese Überlegungen führten zum Begriff TBA - “Technologiebasiertes Assessment” oder “Technology Based Assessment”, wobei Technologie hier eher als Technik verstanden wird (Papierverfahren sind eigentlich auch Technologien).\nLetztlich sind diese Unterscheidungen hier nicht relevant und werden daher synonym verwendet. Man könnte auch eAssessment, digitales Testen usw. verwenden.",
    "crumbs": [
      "Einführung",
      "Computerbasiertes Testen"
    ]
  },
  {
    "objectID": "intro/tba.html#aufgabenentwicklung",
    "href": "intro/tba.html#aufgabenentwicklung",
    "title": "Computerbasiertes Testen",
    "section": "Aufgabenentwicklung",
    "text": "Aufgabenentwicklung\nDie Testaufgaben für die Durchführung der Bildungstrendstudien und für die Vergleichsarbeiten der Länder (VERA; s. KMK) werden am IQB entwickelt. Es erfolgt in jedem Fall eine empirische Erprobung einer jeden Aufgabe (sog. Pilotierung). Für die Aufgaben werden auch die Vorschriften für die Kodierung entwickelt.",
    "crumbs": [
      "Einführung",
      "Computerbasiertes Testen"
    ]
  },
  {
    "objectID": "intro/tba.html#bildungstrend---länderübergreifend",
    "href": "intro/tba.html#bildungstrend---länderübergreifend",
    "title": "Computerbasiertes Testen",
    "section": "Bildungstrend - länderübergreifend",
    "text": "Bildungstrend - länderübergreifend\nDie Studien des Bildungstrends in den Jahrgängen 4 und 9 werden online auf Servern durchgeführt, die das IQB bereitstellt. Ein auf die Durchführung großer Bildungsstudien spezialisierter Auftragnehmer (nachfolgend “AN Durchführung”) bereitet die Testung vor und begleitet die Durchführung in den Schulen vor Ort mit Testleiterinnen und Testleitern. Hier erfolgt auch die Kodierung der Antworten, und das IQB bekommt einen umfassenden Datensatz sowie begleitende Dokumentation.\n\n\n\n\n\nsequenceDiagram\n    participant IQB\n    participant AN as AN Durchführung\n    Actor Schule\n    IQB-&gt;&gt;AN: Nennung Schulen\n    AN-&gt;&gt;Schule: System-Check\n    Schule-&gt;&gt;AN: Meldung Testpersonen\n    IQB-&gt;&gt;AN: Aufgaben\n    AN-&gt;&gt;Schule: Logins\n    note over Schule: Testdurchführung\n    Schule-&gt;&gt;AN: Antworten+Logs roh\n    AN-&gt;&gt;IQB: Ergebnisse kodiert\n    note over IQB: Auswertung, Bericht",
    "crumbs": [
      "Einführung",
      "Computerbasiertes Testen"
    ]
  },
  {
    "objectID": "intro/tba.html#vera---in-jedem-land-separat",
    "href": "intro/tba.html#vera---in-jedem-land-separat",
    "title": "Computerbasiertes Testen",
    "section": "VERA - in jedem Land separat",
    "text": "VERA - in jedem Land separat\nDie jährlichen Vergleichsarbeiten in den Jahrgängen 3 und 8 führt ein Land in eigener Regie durch. Das IQB liefert Aufgaben einschl. Kodierschema sowie Vorschläge für den Testablauf (Testmodule, Testhefte). Im Schema unten ist der häufige Fall dargestellt, dass das Land eine Einrichtung (z. B. ein universitäres Projekt) mit der Durchführung beauftragt.\n\n\n\n\n\nsequenceDiagram\n    participant IQB\n    participant Land\n    participant DE as Durchführende Einrichtung\n    Actor Schule\n    IQB-&gt;&gt;Land: Aufgaben\n    Land-&gt;&gt;DE: Nennung Schulen\n    DE-&gt;&gt;Schule: System-Check\n    Schule-&gt;&gt;DE: Meldung Testpersonen\n    Land-&gt;&gt;DE: Aufgaben\n    DE-&gt;&gt;Schule: Logins\n    note over Schule: Testdurchführung\n    note over Schule: Kodierung\n    Schule-&gt;&gt;DE: Antworten kodiert\n    note over DE: Auswertung\n    DE-&gt;&gt;Schule: Rückmeldung\n    DE-&gt;&gt;Land: Rückmeldung\n\n\n\n\n\n\nDie Antworten werden in diesem Szenario durch die Lehrkräfte kodiert. Nach der Auswertung durch die durchführende Einrichtung meldet diese in die Schulen und dem Auftraggeber die Ergebnisse, um die Unterrichtsentwicklung zu fördern sowie eine Evaluation auf Systemebene zu ermöglichen.\nWenn das Land keine Einrichtung mit der Durchführung beauftragt, fallen die entsprechenden Arbeiten samt Bereitstellung der technischen Infrastruktur dem Land zu.",
    "crumbs": [
      "Einführung",
      "Computerbasiertes Testen"
    ]
  },
  {
    "objectID": "player/index.html",
    "href": "player/index.html",
    "title": "Verona Interfaces - Player",
    "section": "",
    "text": "Beschreibung\nEin Player präsentiert eine Unit und sorgt für die Interaktion mit der Testperson bzw. mit den Befragten. Das grundlegende Modell hierbei ist, dass ein Test bzw. Befragung (nachfolgend synonym) eine Abfolge von inhaltlich getrennten\n\n\nSpezifikation\nPlayer | Komponente, die eine Aufgabe in einer Testanwendung abspielt | Spezifikation (Html), Modell (UML) |"
  },
  {
    "objectID": "editor/index.html",
    "href": "editor/index.html",
    "title": "Verona Interfaces - Editor",
    "section": "",
    "text": "Verona Interfaces - Editor"
  },
  {
    "objectID": "editor/uml.html",
    "href": "editor/uml.html",
    "title": "Verona Interfaces - Editor",
    "section": "",
    "text": "Verona Interfaces - Editor UML"
  },
  {
    "objectID": "editor/msg1_start.html",
    "href": "editor/msg1_start.html",
    "title": "Verona Interfaces - Editor",
    "section": "",
    "text": "Verona Interfaces - Editor Message1 Start"
  },
  {
    "objectID": "player/vopStartCommand.html",
    "href": "player/vopStartCommand.html",
    "title": "Player vopStartCommand",
    "section": "",
    "text": "Verona Interfaces - Player Message1 Start"
  },
  {
    "objectID": "player/vopStateChangedNotification.html",
    "href": "player/vopStateChangedNotification.html",
    "title": "Player vopStateChangedNotification",
    "section": "",
    "text": "Verona Interfaces - Player UML"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Verona Interfaces – Standards für computerbasiertes Testen",
    "section": "",
    "text": "English version\n\n\n\nHere you find a short introduction in English language.\n\n\n\nWillkommen\nIn Deutschland werden viele Erhebungen des Bildungsmonitorings dezentral durchgeführt, d. h. jedes Bundesland folgt eigenen Traditionen und Prioritäten. Auch zentral auf Ebene der KMK abgestimmte Lernstandserhebungen (VERA) benutzen zwar gleiche Aufgaben und methodische Verfahren, technisch und organisatorisch laufen aber auch diese Erhebungen getrennt in den Ländern. Eine zentrale technische Lösung würde in Deutschland den heterogenen Anforderungen nicht gerecht werden können.\nDaraus resultieren sehr hohe Anforderungen an die Modularität und Interoperabilität von technischen Lösungen im computerbasierten Testen. Sämtliche Programmierungen müssen über wohldokumentierte Schnittstellen verfügen. Die Initiative “Verona” hat das Ziel, diese Schnittstellendefinitionen zu erarbeiten und zu pflegen. An dieser Stelle finden Sie Verweise auf die Spezifikationen, aber vor allem ausführliche Erläuterungen für deren Nutzung (im Aufbau).\n\n\nSpezifikationen - Übersicht\nFolgende Spezifikationen liegen vor und werden in englischer Sprache gesondert in Repositorien geführt:\n\n\n\nModul\nBeschreibung\nDirekte Links\n\n\n\n\nPlayer\nKomponente, die eine Aufgabe in einer Testanwendung abspielt\nSpezifikation (Html), Modell (UML)\n\n\nEditor\nKomponente, mit der man Aufgaben gestaltet\nSpezifikation (Html)\n\n\nSchemer\nKomponente, mit der man die Kodieranweisungen für die Antwortverarbeitung festlegt\nSpezifikation (Html)\n\n\nMetadaten\nAlle o. g. Komponenten enthalten Metadaten auf einheitliche Art, die hier beschrieben ist.\n\n\n\n\n\n\nRedaktion\nDie vorliegenden Texte werden unter Federführung des Instituts zur Qualitätsentwicklung im Bildungswesen veröffentlicht. Autor*innen sind ggf. entweder im Kopf eines Dokumentes genannt oder zu Beginn eines größeren Seitenzweiges.\n\n\nLizenz\nAlle Texte sind unter der Lizenz CC0 veröffentlicht. Die Leitlinien zur Sicherung guter wissenschaftlicher Praxis (s. z. B. DFG-pdf) gebieten gleichwohl, dass die Quellen von Informationen genannt werden sollten.\n\n\nHaftungsausschluss\nAuf diesen Webseiten sind Links auf externe Webseiten in besonderer Weise gekennzeichnet (s. oben der Link zum IQB). Wir prüfen diese Quellen regelmäßig, können aber für diese Seiten und die dort hinterlegten Zusatzmaterialien keine Haftung für Richtigkeit, Vollständigkeit und Aktualität übernehmen. Dafür sind ausschließlich deren Betreiber verantwortlich.\n\n\nTechnische Realisierung\nDieser Webauftritt basiert auf Texten in einer einfachen Syntax Markdown, die anschließend in Html und CSS umgesetzt werden. Hierzu wird Quarto verwendet. Sämtliche Dateien für den Inhalt und die Steuerung sind in einem öffentlich zugänglichen Codeverwaltungssystem gespeichert. Eine Anleitung für Änderungen an den Inhalten finden Sie z. B. hier.\n\n\nKontakt\nWenn Sie Inhalte beitragen oder Probleme melden möchten, können Sie die Funktion “Problem melden” nutzen, die rechts auf jeder Seite zu finden ist. Sie werden dann zu GitHub weitergeleitet. Es ist ein Account bei GitHub erforderlich.\nAnsonsten kontakten Sie bitte die IT des IQB.",
    "crumbs": [
      "Start"
    ]
  },
  {
    "objectID": "intro/english.html",
    "href": "intro/english.html",
    "title": "English: About",
    "section": "",
    "text": "The repositories located at /verona-interfaces consist of API specifications for assessment web applications. In Germany, every state / Bundesland conducts assessments in schools and uses different technical solutions. In order to exchange assessment units or to share code modules, the data formats and interfaces need to be specified. The initiative ‘Verona’ works on these specifications.\nThis is an early stage of this endeavour, we did some first steps. To support this process, we publish this documentation in German language. Here you find a general introduction and clarifying of terms etc.\nBesides, the specifications come in separate repositories in English language: Player, Editor, Schemer and Metadata.\nContact: Institute for Educational Quality Improvement.",
    "crumbs": [
      "Einführung",
      "English: About"
    ]
  },
  {
    "objectID": "intro/data-structures.html",
    "href": "intro/data-structures.html",
    "title": "Datenstrukturen",
    "section": "",
    "text": "Ein Testablauf ist stets eine Abfolge von Instruktionen oder Fragen an die Testperson, nach Bedarf angereichert mit Material (Bilder, Text, Audio, Video - sog. Stimulus), auf die sich die Fragen bzw. Handlungsanweisungen dann beziehen. Die kleinste Dateneinheit ist ein durch die Testperson geänderter Zustand, der durch Speichern reproduzierbar wird. Diese kleinste Dateneinheit nennen wir Variable. Sie kann sich auf ein Interaktionselement (z. B. Eingabefeld, Ankreuzkästchen), aber auch auf ein abgespieltes Audio beziehen (Variablenwert ist dann der Fortschritt des Abspielens).\nDer Begriff Item steht für eine Antwort der Testperson, die man mit einem Erwartungswert vergleichen kann und dann den Kategorien “Richtig” und “Falsch” zuordnen kann. Die Quelle für die Antwort ist der Wert einer oder mehrerer Variablen. D. h. die Zustandsänderungen während der Interaktion führen nicht automatisch zu auswertbaren Daten, sondern müssen ggf. aus mehreren Interaktionen zusammengeführt werden.\n\nZ. B. ist in Mathematik ein Format sehr beliebt: “Kreuze an und begründe”. Die Testperson soll sich für eine Option einer Auswahl von Ankreuzkästchen entscheiden, aber bewertet im Sinne der Datenanalyse wird die Entscheidung erst im Zusammenhang mit einem Text, der darunter in ein Eingabefeld geschrieben wurde.\n\nNun kann ein Item auf einer Seite ggf. zusammen mit einem Stimulus präsentiert werden. Über die Navigation kommt man zum nächsten Item. Oft werden jedoch mehrere Items als Gruppe präsentiert, vor allem, wenn sie sich auf denselben Stimulus beziehen. Man erreicht eine höhere Effizienz beim Testen, wenn man zu einem Stimulus nicht nur ein Item vorsieht. Als Unit bezeichnen wir eine Gruppe von Items, die aus testpraktischen oder testtheoretischen Gründen zusammen präsentiert werden.\nDie Unit ist nun die Ebene in der Datenstruktur, die man als beliebig austauschbar innerhalb eines Tests deklariert. Es gibt sogar statistische Maßzahlen, die die unerwünschten Positionseffekte von Units quantifizieren. Natürlich gibt es auch Tests und vor allem Befragungen, bei denen die Abfolge gründlich geplant wird und wo die Units nicht unabhängig voneinander sind. Aber aus Sicht der Datenstrukturen reden wir lange von Units und deren Optimierung, bevor ihr Platz in einer Testabfolge festgelegt wird. Daher sieht der Entwicklungsprozess für Tests zunächst eine Unit- – bzw. im deutschen Sprachgebrauch auch Aufgaben- – Entwicklung vor.\n\n\n\n\n\n\nUnit ist Fokus\n\n\n\nDer Fokus aller Verona-Module liegt auf der Unit. Es werden Daten verarbeitet, die sich stets auf eine Unit beziehen.",
    "crumbs": [
      "Einführung",
      "Datenstrukturen"
    ]
  },
  {
    "objectID": "intro/data-structures.html#modul-editor",
    "href": "intro/data-structures.html#modul-editor",
    "title": "Datenstrukturen",
    "section": "Modul “Editor”",
    "text": "Modul “Editor”\nHier werden in einem interaktiven Prozess alle Medien platziert und alle Interaktionselemente gebaut. Ein Editor ist auf die Autorinnen und Autoren ausgerichtet. Bei den großen Bildungsvergleichsstudien muss sich daher dessen UI/UX an den Fähigkeiten und Gewohnheiten von Lehrkräften orientieren.",
    "crumbs": [
      "Einführung",
      "Datenstrukturen"
    ]
  },
  {
    "objectID": "intro/data-structures.html#modul-player",
    "href": "intro/data-structures.html#modul-player",
    "title": "Datenstrukturen",
    "section": "Modul “Player”",
    "text": "Modul “Player”\nEin Player-Modul dient dem “Abspielen” – also der Präsentation – von Units. Es gibt mehrere Anwendungsfälle:\n\nAnzeige im Testsystem während des Tests\nAnzeige im Testsystem für den Review\nVeröffentlichung von Beispielaufgaben\nVeröffentlichung als permanente Referenz für einen wissenschaftlichen Artikel\nVoransicht im Autorensystem\nDruckbare Ansicht für den Export\nPräsentation während des Kodierprozesses mit den Antwortdaten einer Testperson\nAnzeige für Eltern nach dem Test mit den Antwortdaten ihres Kindes\n\nDiese Liste lässt sich sicherlich erweitern. Je nach Anwendungsfall werden die Antworten gespeichert bzw. wiederhergestellt oder nicht.",
    "crumbs": [
      "Einführung",
      "Datenstrukturen"
    ]
  },
  {
    "objectID": "intro/data-structures.html#unit-definition",
    "href": "intro/data-structures.html#unit-definition",
    "title": "Datenstrukturen",
    "section": "Unit-Definition",
    "text": "Unit-Definition\nDie Unit-Definition ist nicht spezifiziert. Sie wird serialisiert als String gespeichert bzw. zwischen den Komponenten ausgetauscht. Aus diesem Grund ist es wichtig, dass zu der Unit-Definition auch die ID und die Version von Player- und ggf. Editormodul gespeichert werden.\nNatürlich kann ein Entwickler entscheiden, die Unit-Definition ausführlich zu beschreiben und auch z. B. einer Versionierung zu unterziehen. Das IQB tut dies z. B. für zwei einfache Player. Eine solche Spezifikation der Unit-Definition ist aber nicht Gegenstand dieser Verona-Spezifikationen.",
    "crumbs": [
      "Einführung",
      "Datenstrukturen"
    ]
  },
  {
    "objectID": "intro/data-structures.html#modul-schemer",
    "href": "intro/data-structures.html#modul-schemer",
    "title": "Datenstrukturen",
    "section": "Modul “Schemer”",
    "text": "Modul “Schemer”\nMit diesem Verona-Modul werden im Autorensystem die Vorschriften für die Antwortverarbeitung erstellt. Dieses sog. Kodierschema wird in einfachen Fällen bereits von den Aufgabenentwicklerinnen und -entwicklern eingegeben, meist bedarf es aber aufgrund der Komplexität einer besonderen Erfahrung.",
    "crumbs": [
      "Einführung",
      "Datenstrukturen"
    ]
  },
  {
    "objectID": "intro/data-structures.html#variablenliste",
    "href": "intro/data-structures.html#variablenliste",
    "title": "Datenstrukturen",
    "section": "Variablenliste",
    "text": "Variablenliste\nDamit das Kodierschema entwickelt werden kann, muss der Schemer die Variablen kennen, die im Editor angelegt wurden. Diese Datenstruktur ist als Teil des Editors spezifiziert.",
    "crumbs": [
      "Einführung",
      "Datenstrukturen"
    ]
  },
  {
    "objectID": "intro/data-structures.html#antwortdaten",
    "href": "intro/data-structures.html#antwortdaten",
    "title": "Datenstrukturen",
    "section": "Antwortdaten",
    "text": "Antwortdaten\nDie Antwortdaten sind nicht spezifiziert. Sie werden serialisiert als String gespeichert bzw. zwischen den Komponenten ausgetauscht. In der Player-Schnittstelle ist die Angabe eines Datenformates als String vorgesehen, damit nachfolgende Prozesse die Daten sinnvoll verarbeiten können.\nDas IQB hat für die eigenen Module ein einheitliches Antwortformat spezifiziert. Dieses ist jedoch nicht Teil dieser Verona-Spezifikationen.",
    "crumbs": [
      "Einführung",
      "Datenstrukturen"
    ]
  },
  {
    "objectID": "intro/data-structures.html#kodierschema",
    "href": "intro/data-structures.html#kodierschema",
    "title": "Datenstrukturen",
    "section": "Kodierschema",
    "text": "Kodierschema\nDas Kodierschema ist nicht spezifiziert. Es wird serialisiert als String gespeichert bzw. zwischen den Komponenten ausgetauscht. In der Schemer-Schnittstelle ist die Angabe eines Datenformates als String vorgesehen, damit nachfolgende Prozesse die Daten sinnvoll verarbeiten können.\nDas IQB hat für die eigenen Module ein einheitliches Datenformat für das Kodierschema spezifiziert. Dieses ist jedoch nicht Teil dieser Verona-Spezifikationen.",
    "crumbs": [
      "Einführung",
      "Datenstrukturen"
    ]
  },
  {
    "objectID": "intro/modelling.html",
    "href": "intro/modelling.html",
    "title": "Kommunikationsmodell",
    "section": "",
    "text": "sequenceDiagram\n    participant DB as Datenbank\n    participant MH as Modul-Host\n\n    DB-&gt;&gt;MH:Laden Daten\n    participant VM as Verona-Modul\n    MH-&gt;&gt;VM:Initialisierung\n    VM-&gt;&gt;MH:Melde Bereitschaft\n    MH-&gt;&gt;VM:Startkommando mit Daten\n    loop\n        Actor TP as Person\n        VM-&gt;TP:Interaktion\n        VM-&gt;&gt;MH:Melde Änderung Status\n    end\n    VM-xTP:Navigation\n    MH-&gt;&gt;DB:Speichern geänderte Daten\n    MH-xVM:Navigation\n\n\n\n\n\n\n\nInitialisierung\nVerona-Module werden üblicherweise dynamisch geladen und ausgeführt. Wenn ein bestimmtes Modul erforderlich ist und grundsätzlich im System verfügbar, dann wird es zunächst von der Hostanwendung (Frontend im Browser) in den Hauptspeicher geladen.\nAnschließend muss ein &lt;iframe&gt;-Element verfügbar sein. Die Browser unterstützen jetzt alle das Attribut srcdoc, und diesem Attribut wird der Modul-Code zugewiesen. Dies entspricht technisch dem Laden einer Webseite. Dies erfordert eine gewisse (unbekannte) Zeit.\n\n\nNachrichten empfangen\nDie Kommunikation kann nur erfolgen, wenn die Host-Anwendung Nachrichten an das window-Objekt abfängt. Das Modul kann nur allgemein an seine Host-Anwendung Nachrichten schicken, nicht gezielt an eine bestimmte Komponente oder ein bestimmtes DOM-Element. Auf höchster Ebene muss also z. B. so etwas einmalig aufgerufen werden:\n\n\nListener einrichten bei Start der Hostanwendung\n\n window.addEventListener('message', (event: MessageEvent) =&gt; {\n      const msgData = event.data;\n      const msgType = msgData.type;\n      if ((msgType !== undefined) &&\n            (msgType.substr(0, 2) === 'vo')) {\n        this.tcs.postMessage$.next(event);\n      }\n    });\n\nIn diesem Beispiel prüft die Funktion, ob der Typ der Nachricht mit ‘vo’ beginnt. In diesem Fall wird angenommen, dass es sich um eine Nachricht von einem Verona-Modul handelt und ein Observable wird auf einen neuen Wert gesetzt. An passenden Stellen im Host kann dann darauf reagiert werden.\n\n\nVerona-Modul meldet Bereitschaft\nWenn das Modul die eigene Initialisierung abgeschlossen hat, meldet es die Bereitschaft an den Host. Erst ab diesem Zeitpunkt kann man davon ausgehen, dass das Modul Nachrichten empfangen kann. Davor hört es quasi nicht zu.\nIm Verona-Kontext liefert das Modul seine Metadaten mit, d. h. der Host kann prüfen, ob das richtige Modul geladen wurde bzw. ob bestimmte Anpassungen in der Kommunikation erfolgen müssen.\n\n\n\n\n\n\nVorsicht bei mehreren Modulen auf einer Seite\n\n\n\nWenn mehrere Module desselben Typs auf einer Seite eingerichtet werden sollen, muss der Host prüfen, von welchem &lt;iframe&gt;-Element die Bereitschaftsmeldung kam (source/target). Anschließend sollte die sessionId verwendet werden, um die Nachrichten bzw. deren Daten zuzuordnen.\n\n\n\n\nStart-Kommando\nAn das &lt;iframe&gt;-Element wird dann üblicherweise ein Kommando geschickt, das die spezifischen Daten der Unit enthält (Definition, vorherige Antworten, Kodierschema usw.). Damit erstellt bzw. parametrisiert das Modul die erforderlichen Elemente und die Interaktion mit dem User (Testperson, Autorin) kann beginnen.\n\n\nBeispiel Startkommando für Player\n\n  this.postMessageTarget.postMessage({\n        type: 'vopStartCommand',\n        sessionId: this.itemPlayerSessionId,\n        unitDefinition: pendingUnitDef,\n        unitState: {\n          dataParts: pendingUnitDataToRestore\n        },\n        playerConfig: this.tcs.fullPlayerConfig\n      }, '*');\n\nWenn später ein neues Startkommando vom Host geschickt wird, stellt das Modul zunächst den Ausgangszustand nach der Initialisierung wieder her und verfährt dann wie oben. Sollten z. B. mehrere Units hintereinander denselben Player anfordern, muss nicht immer neu das gesamte Modul neu initialisiert werden. Der Player kann über ein neues Start-Kommando “nachgenutzt” werden.\n\n\nInteraktion: Zustandsänderung melden\nWährend der Interaktion meldet das Verona-Modul Änderungen je nach Typ des Moduls. Ob diese Änderungen gspeichert werden, hängt vom jeweiligen Anwendungsfall ab.\n\n\n\n\n\n\nVorsicht Datenflut\n\n\n\nBei schnellen Tastatureingaben oder ambitionierter Beobachtung des Userverhaltens (Logging) fallen sehr viele Daten an. Beim Player-Modul kann man die Daten aufteilen (sog. dataParts), aber auch sonst könnte es viel werden. Die Hostanwendung sollte einen Puffer einrichten und nicht alles sofort wegspeichern. Bei rxjs gibt es beispielsweise den Operator debounceTime.\n\n\n\n\nBeenden: unnötig\nDa Änderungen sofort gemeldet werden, ist ein formelles Beenden des Moduls unnötig. Es gibt bei keinem Verona-Modul Bedarf, vor Entfernen des Moduls bestimmte Funktionen aufzurufen. Wenn das Modul nicht mehr benötigt wird (oben dargestellt als Navigation), kann das &lt;iframe&gt;-Element entfernt oder geleert werden (srcdoc=\"\").\n\n\nKorrekte Zuordnung der Modul-Instanz bzw. der Daten\nBei den Nachrichten gibt es zwei Eigenschaften, die eine korrekte Zuordnung unterstützen:\n\nsessionId: Diese ID wird beim Startkommando vom Host vergeben und wird vom Modul bei jeder Nachricht mitgeschickt. Diese ID wird durch das Modul nicht verändert. Der Host kann darüber das Modul-Element identifizieren und daher sicherstellen, dass bei den überwiegend asynchronen Vorgängen im Browser die Daten stets z. B. der richtigen Unit zugeordnet werden.\ntimeStamp: Auch diese Eigenschaft wird stets vom Modul mitgeschickt. Darüber kann sichergestellt werden, dass die Reihenfolge der Nachrichten nicht vertauscht wird. Es ist stets die jeweils letzte Änderung feststellbar.",
    "crumbs": [
      "Einführung",
      "Kommunikationsmodell"
    ]
  }
]